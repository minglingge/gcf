<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Using IPC in your applications</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<!--link href="tabs.css" rel="stylesheet" type="text/css"-->
</head><body>
 <div id="wrapper">
    <div id="logo_box">
        <a class="img_link" href="http://www.vcreatelogic.com/products/gcf" target="_blank" ><img style="float:left;margin-left:10px;margin-top:5px;margin-bottom:5px;"src="header_gcf_logo.jpg" alt="GCF LOGO"/></a>
        <a class="img_link" href="http://www.vcreatelogic.com/products/gcf" target="_blank" ><img style="float:right;margin-right:10px; margin-top: 30px;" src="header_vcl_logo.jpg" alt="VCL LOGO"/></a>
        <div style="clear:both"></div>
    </div>
    <div class="nav">
        <ul>
            <li class="selectedpage">
                <a class="a-home" href="index.html" >
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a class="a-classes " href="classes.html">
                    <span>All Classes</span>
                </a>
            </li>
            <li>
                <a class="a-home " href="gcf_modules.html">
                    <span>Modules</span>
                </a>
            </li>
            <li>
                <a class="a-home " href="gcf_guides_and_videos.html">
                    <span>Guides & Videos</span>
                </a>
            </li>
            <li>
                <a class="a-home " href="gcf_tools_and_inbuilt_components.html">
                    <span>Tools & Components</span>
                </a>
            </li>
        </ul>
    </div>
    <div id="main-content">
        <div class="inside">
        <div>
<!-- Generated by Doxygen 1.8.16 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Using IPC in your applications </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The IPC module in GCF makes it possible for you to host objects in your application for communication with other applications AND to invoke methods on objects in other applications. In the following paragraphs we explain how certain key communication scenarios work.</p>
<h1><a class="anchor" id="gcf_using_ipc_0"></a>
Enabling IPC communication with your application</h1>
<p>To allow incoming IPC communication, you should create an instance of <a class="el" href="class_g_c_f_1_1_ipc_server.html">GCF::IpcServer</a> and have it listen for incoming requests.</p>
<div class="fragment"><div class="line"><a class="code" href="class_g_c_f_1_1_ipc_server.html">GCF::IpcServer</a> server;</div>
<div class="line"><span class="keywordflow">if</span>( server.listen() )</div>
<div class="line">    <span class="comment">// Listening for incoming requests</span></div>
</div><!-- fragment --><p><a class="el" href="class_g_c_f_1_1_ipc_server.html">GCF::IpcServer</a> is a subclass of <code>QTcpServer</code>. The GCF::IpcServer::listen() method basically creates a server socket and listens for incoming socket connection requests. Every connection request received at this socket will be ackowledged and responded.</p>
<p>An application can have any-number of instances of <a class="el" href="class_g_c_f_1_1_ipc_server.html">GCF::IpcServer</a> created. Each server should listen on a different port. You can implement your own mechanisms to publish the availablility of servers and communicate that information to client-GCF applications. You can also make use of <a class="el" href="class_g_c_f_1_1_ipc_server_discovery.html">GCF::IpcServerDiscovery</a> to discover servers in the Local Area Network.</p>
<h1><a class="anchor" id="gcf_using_ipc_1"></a>
"Exposing" objects for IPC communication</h1>
<p>Any object in your application can be made available for IPC communication </p><ul>
<li>adding the object to the object tree (<a class="el" href="class_g_c_f_1_1_application_services.html#a22657bd136cbf7a285cf0b273a40963a">GCF::ApplicationServices::objectTree()</a>), if the object has not already been added to it. </li>
<li>setting the <code>allowmetaaccess</code> key to <code>true</code> against the information key=value map of the object.</li>
</ul>
<p>The following code snippet shows you how</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyClass : <span class="keyword">public</span> QObject</div>
<div class="line">{</div>
<div class="line">    Q_OBJECT</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    Q_INVOKABLE <a class="code" href="class_g_c_f_1_1_result.html">GCF::Result</a> method1(<span class="keyword">const</span> QVariant &amp;p1, <span class="keyword">const</span> QVariant &amp;p2, ...)</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyClass *obj = <span class="keyword">new</span> MyClass(gApp);</div>
<div class="line">QVariantMap objInfo;</div>
<div class="line">objInfo[<span class="stringliteral">&quot;allowmetaaccess&quot;</span>] = <span class="keyword">true</span>;</div>
<div class="line"><span class="keyword">new</span> <a class="code" href="class_g_c_f_1_1_object_tree_node.html">GCF::ObjectTreeNode</a>(gAppService-&gt;objectTree()-&gt;rootNode(), <span class="stringliteral">&quot;MyService&quot;</span>, obj, objInfo);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now methods on obj can be invoked from other applications.</span></div>
</div><!-- fragment --><p>To mark objects for remote access in the content file, you can</p>
<div class="fragment"><div class="line">&lt;content&gt;</div>
<div class="line">    ....</div>
<div class="line">    ....</div>
<div class="line">    &lt;<span class="keywordtype">object</span> name=<span class="stringliteral">&quot;...&quot;</span> allowMetaAccess=<span class="stringliteral">&quot;true&quot;</span> /&gt;</div>
<div class="line">    ....</div>
<div class="line">    ....</div>
<div class="line">&lt;/content&gt;</div>
</div><!-- fragment --><h1><a class="anchor" id="gcf_using_ipc_2"></a>
Service method rules</h1>
<p>Public invokable (signal, slot and Q_INVOKABLE) methods in a "exposed" object can be remotely invoked by other applications. Such methods are called "service methods". Service methods have to adhere to the following rules</p>
<ul>
<li>Method name must be unabiguous. No two service methods must have the same name, even though C++ allows for method overloading.</li>
</ul>
<ul>
<li>Method parameters can be of type: <code>int</code>, <code>bool</code>, <code>double</code>, <code>QString</code>, <code>QStringList</code>, <code>QVariant</code>, <code>QVariantList</code>, <code>QVariantMap</code> or <code>QByteArray</code>. All other types must be represented in terms of these types. <b>NOTE:</b> Custom types can be registered using <code>qRegisterMetaType</code> and their streaming operators can be registered using <code>qRegisterMetaTypeStreamOperators</code>. Such types can be accepted as <code>QVariant</code>. Example: <div class="fragment"><div class="line"><span class="keyword">struct </span>MyType { ... };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register the type</span></div>
<div class="line">qRegisterMetaType&lt;MyType&gt;(<span class="stringliteral">&quot;MyType&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register streaming operators for the type</span></div>
<div class="line">QDataStream &amp;operator&lt;&lt;(QDataStream &amp;out, <span class="keyword">const</span> MyType &amp;myObj) { ... }</div>
<div class="line">QDataStream &amp;operator&gt;&gt;(QDataStream &amp;in, MyType &amp;myObj) { ... }</div>
<div class="line">qRegisterMetaTypeStreamOperators&lt;MyType&gt;(<span class="stringliteral">&quot;MyType&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyClass : <span class="keyword">public</span> QObject</div>
<div class="line">{</div>
<div class="line">    Q_OBJECT</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    Q_INVOKABLE <a class="code" href="class_g_c_f_1_1_result.html">GCF::Result</a> serviceMethod(<span class="keyword">const</span> QVariant&amp; arg) {</div>
<div class="line">        MyType type = arg.value&lt;MyType&gt;();</div>
<div class="line">        <span class="keywordflow">return</span> this-&gt;method(type);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="class_g_c_f_1_1_result.html">GCF::Result</a> method(<span class="keyword">const</span> MyType &amp;type) { ... }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>Return types can be <code>void</code>, <code>int</code>, <code>bool</code>, <code>double</code>, <code>QString</code>, <code>QStringList</code>, <code>QVariant</code>, <code>QVariantList</code>, <code>QVariantMap</code>, <code>QByteArray</code> or <a class="el" href="class_g_c_f_1_1_result.html">GCF::Result</a>.</li>
</ul>
<ul>
<li>Methods should return fast. They should never consume more than 60 seconds of clock time. If they do take longer than that, then callers should be made aware of that and they should adjust their call timeout using <a class="el" href="class_g_c_f_1_1_ipc_call.html#a01618782e9db038d786a817480bb846b">GCF::IpcCall::setTimeoutDuration()</a>.</li>
</ul>
<h1><a class="anchor" id="gcf_using_ipc_3"></a>
Invoking service methods</h1>
<p>To invoke a service method, you can make use of the <a class="el" href="class_g_c_f_1_1_ipc_call.html">GCF::IpcCall</a> class. One instance of this class can be used to make only one service call. Example:</p>
<div class="fragment"><div class="line">QHostAddress addr = ...;</div>
<div class="line">quint16 port = ...;</div>
<div class="line"><a class="code" href="class_g_c_f_1_1_ipc_call.html">GCF::IpcCall</a> *call = <span class="keyword">new</span> <a class="code" href="class_g_c_f_1_1_ipc_call.html">GCF::IpcCall</a>(addr, port, <span class="stringliteral">&quot;Application.MyService&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;method1&quot;</span>, QVariantList() &lt;&lt; ... &lt;&lt; ...);</div>
<div class="line">connect(call, SIGNAL(done(<span class="keywordtype">bool</span>)), ..., SLOT(callDone(<span class="keywordtype">bool</span>)));</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> abcd::callDone(<span class="keywordtype">bool</span> val) {</div>
<div class="line">    <a class="code" href="class_g_c_f_1_1_ipc_call.html">GCF::IpcCall</a> *call = qobject_cast&lt;GCF::IpcCall *&gt;(this-&gt;sender());</div>
<div class="line">    <span class="keywordflow">if</span>(val) {</div>
<div class="line">        QVariant result = call-&gt;<a class="code" href="class_g_c_f_1_1_ipc_call.html#a5d7bbd1eba2b62c31f1347b66916651e">result</a>();</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        QString errMsg = call-&gt;<a class="code" href="class_g_c_f_1_1_ipc_call.html#a895b648f5336c08000a11fc6da5853f4">errorMessage</a>();</div>
<div class="line">        <span class="comment">// Display errMsg</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <a class="el" href="class_g_c_f_1_1_ipc_call.html">GCF::IpcCall</a> class always works in asynchronous mode. To use the class in blocking mode you can make use of the <a class="el" href="class_g_c_f_1_1_ipc_call.html#a5a349d14008368c3bc7f065a45d8c5d3">GCF::IpcCall::waitForDone()</a> method on the call object. This method waits for the call to complete before it returns. The function returns true if the call was successful, false otherwise. <b>NOTE:</b> the <code>waitForDone()</code> method waits for a 10 seconds (or a value set using <a class="el" href="class_g_c_f_1_1_ipc_call.html#a01618782e9db038d786a817480bb846b">GCF::IpcCall::setTimeoutDuration()</a>). Example:</p>
<div class="fragment"><div class="line">QHostAddress addr = ...;</div>
<div class="line">quint16 port = ...;</div>
<div class="line"><a class="code" href="class_g_c_f_1_1_ipc_call.html">GCF::IpcCall</a> *call = <span class="keyword">new</span> <a class="code" href="class_g_c_f_1_1_ipc_call.html">GCF::IpcCall</a>(addr, port, <span class="stringliteral">&quot;Application.MyService&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;method1&quot;</span>, QVariantList() &lt;&lt; ... &lt;&lt; ...);</div>
<div class="line"><span class="keywordflow">if</span>( call-&gt;<a class="code" href="class_g_c_f_1_1_ipc_call.html#a5a349d14008368c3bc7f065a45d8c5d3">waitForDone</a>() ) {</div>
<div class="line">    QVariant result = call-&gt;<a class="code" href="class_g_c_f_1_1_ipc_call.html#a5d7bbd1eba2b62c31f1347b66916651e">result</a>();</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    QString errMsg = call-&gt;<a class="code" href="class_g_c_f_1_1_ipc_call.html#a895b648f5336c08000a11fc6da5853f4">errorMessage</a>();</div>
<div class="line"><span class="comment">// Display errMsg</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="gcf_using_ipc_4"></a>
Signal/Slot connections across applications</h1>
<p>You can make use of <a class="el" href="class_g_c_f_1_1_ipc_remote_object.html">GCF::IpcRemoteObject</a> to maintain a persistent connection with a remote object. Signal/Slot connections can be made between <a class="el" href="class_g_c_f_1_1_ipc_remote_object.html">GCF::IpcRemoteObject</a> and any other object in the application to</p>
<ul>
<li>connect signal from a local object to a member (signal or slot) in a remote object </li>
<li>connect signal from the remote object to a member (signal or slot) in a local object</li>
</ul>
<p>In addition to remote-signal/slot connections, <a class="el" href="class_g_c_f_1_1_ipc_remote_object.html">GCF::IpcRemoteObject</a> can be used to fetch properties of the remote object and also invoke methods on the remote object.</p>
<p>The following code snippet shows you how to create an instance of <a class="el" href="class_g_c_f_1_1_ipc_remote_object.html">GCF::IpcRemoteObject</a> and prepare to use it.</p>
<div class="fragment"><div class="line"><a class="code" href="class_g_c_f_1_1_ipc_remote_object.html">GCF::IpcRemoteObject</a> *remoteObj = <span class="keyword">new</span> <a class="code" href="class_g_c_f_1_1_ipc_remote_object.html">GCF::IpcRemoteObject</a>(addr, port, <span class="stringliteral">&quot;Application.MyService&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wait for the object to get activated</span></div>
<div class="line"><a class="code" href="class_g_c_f_1_1_signal_spy.html">GCF::SignalSpy</a> spy(remoteObj, SIGNAL(activated()));</div>
<div class="line">spy.wait();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>( remoteObj-&gt;<a class="code" href="class_g_c_f_1_1_ipc_remote_object.html#af9a3fe129807efd53e0a8e001335b9a0">isActivated</a>() ) {</div>
<div class="line">    <span class="comment">// Connection to the remote object is now activated</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>You can make use of the <a class="el" href="group__gcf__ipc.html#ga9914677e892972e036b1f7498110c7a4">GCF::ipcConnect()</a> methods to make signal/slot connections between a local object and remote object. Example:</p>
<div class="fragment"><div class="line"><a class="code" href="class_g_c_f_1_1_ipc_remote_object.html">GCF::IpcRemoteObject</a> *remoteApp = <span class="keyword">new</span> <a class="code" href="class_g_c_f_1_1_ipc_remote_object.html">GCF::IpcRemoteObject</a>(addr, port, <span class="stringliteral">&quot;Application&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wait for the object to get activated</span></div>
<div class="line"><a class="code" href="class_g_c_f_1_1_signal_spy.html">GCF::SignalSpy</a> spy(remoteApp, SIGNAL(activated()));</div>
<div class="line">spy.wait();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// When a local button is clicked, we want the remoteApp to quit.</span></div>
<div class="line">QPushButton *quitButton = ...;</div>
<div class="line"><a class="code" href="group__gcf__ipc.html#ga9914677e892972e036b1f7498110c7a4">GCF::ipcConnect</a>(quitButton, SIGNAL(clicked()), remoteApp, SLOT(quit()));</div>
</div><!-- fragment --><h1><a class="anchor" id="gcf_using_ipc_5"></a>
Discovering remote servers</h1>
<p>You can use <a class="el" href="class_g_c_f_1_1_ipc_server_discovery.html">GCF::IpcServerDiscovery</a> class to discover address and port numbers of <a class="el" href="class_g_c_f_1_1_ipc_server.html">GCF::IpcServer</a> objects in GCF applications running on the local-area-network. The following example shows how <a class="el" href="class_g_c_f_1_1_ipc_server_discovery.html">GCF::IpcServerDiscovery</a> can be used in your applications</p>
<div class="fragment"><div class="line">quint port = 55001;</div>
<div class="line"><a class="code" href="class_g_c_f_1_1_ipc_server_discovery.html">GCF::IpcServerDiscovery</a> discovery;</div>
<div class="line">discovery.<a class="code" href="class_g_c_f_1_1_ipc_server_discovery.html#a0f0a113185af3348a74975ddb50f3faa">start</a>(port);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// GCF::IpcServerDiscovery emits a foundServer() signal whenever it detects the</span></div>
<div class="line"><span class="comment">// presense of a new server.</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_g_c_f_1_1_ipc_server.html">GCF::IpcServer</a> </dd>
<dd>
<a class="el" href="class_g_c_f_1_1_ipc_call.html">GCF::IpcCall</a> </dd>
<dd>
<a class="el" href="class_g_c_f_1_1_ipc_remote_object.html">GCF::IpcRemoteObject</a> </dd>
<dd>
<a class="el" href="class_g_c_f_1_1_ipc_server_discovery.html">GCF::IpcServerDiscovery</a> </dd>
<dd>
GCF::ipcConnect </dd>
<dd>
<a class="el" href="gcf_tictactoe.html">TicTacToe - Example application for GCF's IPC module.</a> </dd>
<dd>
<a class="el" href="gcf_communique.html">Communique - Example application for GCF's IPC module.</a> </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aclass_g_c_f_1_1_ipc_remote_object_html_af9a3fe129807efd53e0a8e001335b9a0"><div class="ttname"><a href="class_g_c_f_1_1_ipc_remote_object.html#af9a3fe129807efd53e0a8e001335b9a0">GCF::IpcRemoteObject::isActivated</a></div><div class="ttdeci">bool isActivated() const</div><div class="ttdef"><b>Definition:</b> IpcRemoteObject.cpp:274</div></div>
<div class="ttc" id="aclass_g_c_f_1_1_ipc_call_html_a895b648f5336c08000a11fc6da5853f4"><div class="ttname"><a href="class_g_c_f_1_1_ipc_call.html#a895b648f5336c08000a11fc6da5853f4">GCF::IpcCall::errorMessage</a></div><div class="ttdeci">QString errorMessage() const</div><div class="ttdef"><b>Definition:</b> IpcCall.cpp:202</div></div>
<div class="ttc" id="aclass_g_c_f_1_1_ipc_server_discovery_html"><div class="ttname"><a href="class_g_c_f_1_1_ipc_server_discovery.html">GCF::IpcServerDiscovery</a></div><div class="ttdoc">This class can be used to discover GCF::IpcServer instances on LAN.</div><div class="ttdef"><b>Definition:</b> IpcServerDiscovery.h:65</div></div>
<div class="ttc" id="aclass_g_c_f_1_1_signal_spy_html"><div class="ttname"><a href="class_g_c_f_1_1_signal_spy.html">GCF::SignalSpy</a></div><div class="ttdoc">Enables introspection of signal emissions from a QObject.</div><div class="ttdef"><b>Definition:</b> SignalSpy.h:105</div></div>
<div class="ttc" id="aclass_g_c_f_1_1_ipc_server_html"><div class="ttname"><a href="class_g_c_f_1_1_ipc_server.html">GCF::IpcServer</a></div><div class="ttdoc">Provides a IPC server based on QTcpServer.</div><div class="ttdef"><b>Definition:</b> IpcServer.h:45</div></div>
<div class="ttc" id="aclass_g_c_f_1_1_ipc_call_html_a5d7bbd1eba2b62c31f1347b66916651e"><div class="ttname"><a href="class_g_c_f_1_1_ipc_call.html#a5d7bbd1eba2b62c31f1347b66916651e">GCF::IpcCall::result</a></div><div class="ttdeci">QVariant result() const</div><div class="ttdef"><b>Definition:</b> IpcCall.cpp:212</div></div>
<div class="ttc" id="aclass_g_c_f_1_1_result_html"><div class="ttname"><a href="class_g_c_f_1_1_result.html">GCF::Result</a></div><div class="ttdoc">This class allows representation of the result of a process and/or function.</div><div class="ttdef"><b>Definition:</b> GCFGlobal.h:58</div></div>
<div class="ttc" id="aclass_g_c_f_1_1_ipc_server_discovery_html_a0f0a113185af3348a74975ddb50f3faa"><div class="ttname"><a href="class_g_c_f_1_1_ipc_server_discovery.html#a0f0a113185af3348a74975ddb50f3faa">GCF::IpcServerDiscovery::start</a></div><div class="ttdeci">GCF::Result start(quint16 port=0)</div><div class="ttdef"><b>Definition:</b> IpcServerDiscovery.cpp:200</div></div>
<div class="ttc" id="aclass_g_c_f_1_1_object_tree_node_html"><div class="ttname"><a href="class_g_c_f_1_1_object_tree_node.html">GCF::ObjectTreeNode</a></div><div class="ttdoc">Represents a node in GCF::ObjectTree.</div><div class="ttdef"><b>Definition:</b> ObjectTree.h:111</div></div>
<div class="ttc" id="agroup__gcf__ipc_html_ga9914677e892972e036b1f7498110c7a4"><div class="ttname"><a href="group__gcf__ipc.html#ga9914677e892972e036b1f7498110c7a4">GCF::ipcConnect</a></div><div class="ttdeci">GCF::Result ipcConnect(QObject *sender, const char *signal, GCF::IpcRemoteObject *receiver, const char *member)</div><div class="ttdef"><b>Definition:</b> IpcRemoteObject.h:110</div></div>
<div class="ttc" id="aclass_g_c_f_1_1_ipc_call_html"><div class="ttname"><a href="class_g_c_f_1_1_ipc_call.html">GCF::IpcCall</a></div><div class="ttdoc">Make calls on methods in a remote object.</div><div class="ttdef"><b>Definition:</b> IpcCall.h:44</div></div>
<div class="ttc" id="aclass_g_c_f_1_1_ipc_call_html_a5a349d14008368c3bc7f065a45d8c5d3"><div class="ttname"><a href="class_g_c_f_1_1_ipc_call.html#a5a349d14008368c3bc7f065a45d8c5d3">GCF::IpcCall::waitForDone</a></div><div class="ttdeci">bool waitForDone()</div><div class="ttdef"><b>Definition:</b> IpcCall.cpp:256</div></div>
<div class="ttc" id="aclass_g_c_f_1_1_ipc_remote_object_html"><div class="ttname"><a href="class_g_c_f_1_1_ipc_remote_object.html">GCF::IpcRemoteObject</a></div><div class="ttdoc">This class allows you to maintain a persistent connection with a remote object.</div><div class="ttdef"><b>Definition:</b> IpcRemoteObject.h:49</div></div>
</div>
</div>
</div>
<div class="footer_content">
<table width="100%" class="footer">
<tr>
<td align="left" width="50%">Copyright &copy; 2013-2019,
 <a class="el" href="http://www.vcreatelogic.com" target="_black">VCreate Logic Private Limited</a></td>
<td align="right" width="50%"><a class="el" href="http://www.vcreatelogic.com/products/gcf" target="_black">GCF - Generic Component Framework</a></td>
</tr>
</table>
</div>
</div>
</body>
</html>
